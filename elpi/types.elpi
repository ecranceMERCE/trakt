%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                           %                     Trakt                       %
%  _______        _    _    %            Copyright (C) 2022 MERCE             %
% |__   __|      | |  | |   %     (Mitsubishi Electric R&D Centre Europe)     %
%    | |_ __ __ _| | _| |_  %        Enzo Crance <enzo.crance@inria.fr>       %
%    | | '__/ _` | |/ / __| %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%    | | | | (_| |   <| |_  % This file is distributed under the terms of the %
%    |_|_|  \__,_|_|\_\\__| %   GNU Lesser General Public License Version 3   %
%                           %  (see LICENSE file for the text of the license) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% n-ary representation of Coq function types
% (output type, input types)
typeabbrev coqfuntype (pair term (list term)).

% prod2 N T T' F
% new constructor for terms allowing to annotate a universal quantifier with another type
% we use the annotation to remember which type was there before changing the quantifier
type prod2 (name -> term -> term -> (term -> term) -> term).

% cast E
% new constructor for embedding functions (cast is just boxing the underlying term E)
type cast term -> term.

% must update copy because it does not know the new constructors

copy (prod2 N T T' F) (prod2 N T1 T1' F1) :-
  !, copy T T1,
  copy T' T1',
  pi x\ copy (F x) (F1 x).

copy (cast T) (cast T') :-
  copy T T'.

% type variance annotation, so that logical connectors like implication or negation are supported
kind type-variance type.

type covariant type-variance.
type contravariant type-variance.

% structure of the various proofs generated by the tactic
kind proof type.

% proof.trans TVar Ps
%   TVar: order in which we need to compose the proofs
%   Ps: proofs to compose
type proof.trans (type-variance -> (list proof) -> proof).

% proof.lift-eq TVar Ctx P
%   TVar: determines if we are lifting x = y to prove ?G x -> ?G y or ?G y -> ?G x
%   Ctx: context to give to @eq_rect to lift an equality proof to an implication on the whole goal
%   P: equality proof
type proof.lift-eq (type-variance -> (term -> term) -> term -> proof).

type proof.of-term (term -> proof).

% proof.lift-logic ML Ps
%   ML: morphism lemma for a logical connector ?C, allowing to prove
%       ?C ?A1 ... ?An -> ?C ?B1 ... ?Bn from the proofs on the arguments
%   Ps: proofs on the arguments (?Ai -> ?Bi)
type proof.lift-logic (term -> (list proof) -> proof).

% proof.forall T PF CoqPF
%   T: type of the quantified variable for the proof
%   PF: elpi function making the proof on the specialised terms (takes a term of type T)
%   CoqPF: elpi function making the proof on the quantified terms
% NB: here we use these 2 elpi functions because the variable given to the first (PF) can be of
%     different types according to the type variance, and the variable is given as one of the
%     binders of the final proof
%     fun H (*x* : T) ... => *use proof made with PF, specialised with x* ...
type proof.forall (term -> (term -> proof) -> ((term -> term) -> term) -> proof).

% same but the proofs depend on 2 variables (say, a term and a proof)
type proof.forall2
  (term -> (term -> term) -> (term -> term -> proof) -> ((term -> term -> term) -> term) -> proof).

% identity (no proof)
type proof.none (term -> proof).

% database of user declarations

pred embedding
  o:term, % source type
  o:term, % target type
  o:term, % E: forward embedding function
  o:term, % RE: backward embedding function
  o:term, % proof that λx.RE (E x) is an identity
  o:term, % proof that λx.E (RE x) is an identity if the condition is true for x
  o:(option term), % the logic used to express the condition (bool or Prop)
  o:(option term), % the embedding condition (e.g. positivity for nat)
  o:(option term). % a proof that this condition is always true for any embedded term

pred logical-connector
  o:term, % source connector
  o:term, % target connector
  o:(list type-variance), % the type variances of the arguments
  o:term, % proof that this connector is a morphism for implication
  o:term, % reflection lemma
  o:term. % reflection lemma the other way

pred symbol
  o:term, % S: source symbol
  o:term, % S': target symbol
  o:term. % proof that embedding S gives S'

pred relation
  o:term, % R: source relation
  o:term, % type of the arguments of R
  o:term, % output logic of R (bool or Prop)
  o:term, % R': target relation
  o:term, % type of the arguments of R'
  o:term, % output logic of R'
  o:term. % proof that embedding R is equivalent to R'

pred conversion-allowed
  o:term. % head term allowed to trigger Coq conversion
